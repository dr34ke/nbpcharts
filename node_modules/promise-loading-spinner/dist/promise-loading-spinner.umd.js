(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.PromiseLoadingSpinner = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var defaults = {
        delay: 300,
        closeDelay: 10,
        initDelay: 1000,
        loaderElement: '#js-page-loader',
        classActive: 'is-active',
    };
    var Loader = /** @class */ (function () {
        function Loader(cfg) {
            var _this = this;
            if (cfg === void 0) { cfg = {}; }
            this.loaderPromises = [];
            this.suppressOnInit = false;
            this.timeout = null;
            this.closingTimeout = null;
            var config = __assign(__assign({}, defaults), cfg);
            var loaderElement = config.loaderElement, initDelay = config.initDelay;
            this.config = config;
            this.el = loaderElement instanceof HTMLElement
                ? loaderElement : document.querySelector(loaderElement);
            if (initDelay) {
                this.suppressOnInit = true;
                setTimeout(function () {
                    _this.suppressOnInit = false;
                }, initDelay);
            }
        }
        Loader.prototype.loader = function (promise) {
            var _this = this;
            var _a = this, el = _a.el, suppressOnInit = _a.suppressOnInit, loaderPromises = _a.loaderPromises, config = _a.config;
            var classActive = config.classActive, delay = config.delay, closeDelay = config.closeDelay;
            if (!suppressOnInit && el) {
                var isFirstLoader = !loaderPromises.length;
                loaderPromises.push(promise);
                var showLoader_1 = function () {
                    el.classList.add(classActive);
                };
                if (isFirstLoader) { // Only the first loader needs to initialize the show functionality
                    if (!this.closingTimeout) {
                        if (delay) {
                            // Show loader after a delay. For operation that are finished fast enough no loader is shown.
                            this.timeout = setTimeout(function () {
                                showLoader_1();
                                _this.timeout = null;
                            }, delay);
                        }
                        else {
                            showLoader_1();
                        }
                    }
                    else {
                        // Another operation finished shortly before. To avoid flickering the loader closes later.
                        // But here we don't need to close it because another operation starts.
                        clearTimeout(this.closingTimeout);
                        this.closingTimeout = null;
                    }
                }
                var finished = function () {
                    if (_this.timeout && loaderPromises.length === 1) {
                        // We close the last operation before the loader was shown. There is no need anymore to show it.
                        clearTimeout(_this.timeout);
                        _this.timeout = null;
                    }
                    loaderPromises.splice(loaderPromises.indexOf(promise), 1);
                    if (!loaderPromises.length) {
                        if (closeDelay) {
                            // The last operation has finished. Show loader a bit longer so there is no flickering when an operation
                            // starts shortly after.
                            _this.closingTimeout = setTimeout(function () {
                                el.classList.remove(classActive);
                                _this.closingTimeout = null;
                            }, closeDelay);
                        }
                        else {
                            el.classList.remove(classActive);
                        }
                    }
                };
                promise.then(finished, finished);
            }
            return promise;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Loader.prototype.wrapFunction = function (fnc) {
            var loaderCtx = this; // eslint-disable-line @typescript-eslint/no-this-alias
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return loaderCtx.loader(fnc.apply(this, args));
            };
        };
        return Loader;
    }());

    return Loader;

})));
